---
title: "roxyblox"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{roxyblox}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(roxyblox)
```

# Introduction

The purpose of the roxyblox package is to provide a way for Carpentries lesson
contributors to write challenge and solution blocks in a simple and
straightforward manner. We have taken inspiration from the Roxygen2 style of
writing documentation above code blocks. For example, here is a function with
documentation written above it with minimal markup:

```{r roxyxample1}
#' Add two numbers
#'
#' @param x a number
#' @param y a number
#' @return the sum of x and y
#'
#' @export
#' @examples
#' add(1, 2) # 3
#' add(2, 1)
add <- function(x, y) {
  x + y
}
```

In the same vein, we could use this sort of syntax to create our own solution
for generating special callout blocks within the Carpentries lessons, which
currently rely on the Kramdown interpreter with Jekyll:

````markdown
```{ENGINE, eval = FALSE}
#' @challenge
#' ## Challenge 2
#' 
#' Given the following code:
#+{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
#' 
#' Write a subsetting command to return the values in x that are greater than 4 and less than 7.
#'
#' @solution
#' 
#' ## Solution to challenge 2
#+{r}
x_subset <- x[x<7 & x>4]
print(x_subset)
```
````

## Naming ideas

This package is currently called `{roxyblox}`, but I think it's a bit clunky.
One of the things we want to consider is the fact that we should be able to run
any language within the chunks. Moreover, because the roxygen tags would
indicate the type of block to be generated, we would want the package name to be
the same as the block name to avoid any confusion. I'm adding a couple of
potential names that are related in some fashion to carpentries, but we
definitely do not have to follow this.

Add more names as you see fit here:

 - {roxyblox}
 - {pegboard} <https://en.wikipedia.org/wiki/Pegboard>
 - {mitre} <https://en.wikipedia.org/wiki/Mitre_joint>
 - {sawhorse} <https://en.wikipedia.org/wiki/Sawhorse>
 - {particleboard} <https://en.wikipedia.org/wiki/Particle_board>

## Motivation

The benefit of this is method that it's legible without conversion. Our
motivation for writing this stems from the way challenge blocks in lessons are
constructed via block quotes. While this is fine for regular text, it can be
challenging to write code examples AND ensure that they will render correctly.
Consider the following block quote (taken from episode 6 of R novice gapminder)
that gives a challenge block with a single solution block nested within it.
Within each of these blocks is a code block with R code that should be evaluated.

```
> ## Challenge 2
> 
> Given the following code:
> 
> ```{r}
> x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
> names(x) <- c('a', 'b', 'c', 'd', 'e')
> print(x)
> ```
> 
> Write a subsetting command to return the values in x that are greater than 4 and less than 7.
> 
> > ## Solution to challenge 2
> > 
> > ```{r}
> > x_subset <- x[x<7 & x>4]
> > print(x_subset)
> > ```
> {: .solution}
{: .challenge}
```

When this gets processed by Jekyll, the kramdown tags (`{: .soltuion}`, `{: .challenge}`) are replaced by tags whose underlying css describes how the 
elements should be displayed. Here is what the resulting HTML would look like:

````html
<blockquote class="challenge">

  <h2 id="challenge-2">Challenge 2</h2>

  <p>Given the following code:</p>

  <!-- SNIP: highlighted R code and output -->

  <p>Write a subsetting command to return the values in x that are greater than 4 and less than 7.</p>

  <blockquote class="solution">
    <h2 id="solution-to-challenge-2">Solution to challenge 2<span class="fold-unfold glyphicon glyphicon-collapse-down"></span></h2>

    <!-- SNIP: highlighted R code and output -->

  </blockquote>
</blockquote>
````

The nesting here can be a significant distraction for contributors to lesson
templates because of a few reasons:

1. if you don't have the spacing correct, Jekyll throws strange errors
2. syntax highlighting is not available within block quotes
3. evaluation of code within a block quote involves manual copying and pasting

Of course, it's the two tags at the bottom that are doing *a lot* of the work in
conjunction with the kramdown parser employed by Jekyll. 

The idea behind this package is to write an engine for knitr that will parse a
code block that looks like this:

```{r "245:1-264:14", eval = FALSE}
#' @challenge
#' ## Challenge 2
#'
#' Given the following code:
#+{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c("a", "b", "c", "d", "e")
print(x)
#'
#' Write a subsetting command to return the values in x that are greater than 4 and less than 7.
#'
#' @solution
#'
#' ## Solution to challenge 2
#+{r}
x_subset <- x[x < 7 & x > 4]
print(x_subset)
```

into something that looks closer to this:


````markdown
<blockquote class="challenge" markdown="1">

## Challenge 2

Given the following code:

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
print(x)
```

Write a subsetting command to return the values in x that are greater than 4 and less than 7.

<blockquote class="solution" markdown="1">

## Solution to challenge 2

```{r}
x_subset <- x[x<7 & x>4]
print(x_subset)
```

</blockquote>
</blockquote>
````


> Note: we have to add markdown="1" to these tags so that the markdown elements
> are processed by the kramdown interpreter.


# Specifications

At the moment, we are writing this to parse code chunks within RMarkdown
documents, with the emphasis on R chunks. Because support for python exists via
{reticulate}, it should be possible to extend this to Python, but the initial
proof of concept will focus on R.

Importantly, we are not seeking to introduce novel concepts; we want to use
existing terminology and tokens to make writing these blocks less complex

## Chunk specifications

 - Chunk engines will generate markdown blocks with rendered code output
 - Roxygen comments (`#' `) indicate markdown prose
 - Chunk option comments (`#+{r ...}`) immediately precede code and are
   independent of the overlying chunk
 - Code within the chunk will not have any extra markup
 - Code will be evaluated in the current environment
 
## Tag specifications

div classes are indicated within the Roxygen comments with a roxygen tag
and the name of the div type (e.g. `#' @challenge` is the beginning of a
challenge block)

 - Each chunk represents a single div class, which can have any number
   of nested div classes within
 - The first line of each chunk be the div tag (e.g. `#' @callout`)
 - Nested block quotes can be specified with a new tag (e.g. `#' @solution`)
 - To exit a nested block, add the tag for the parent block (e.g. `#' @challenge`
   after a solution block)
 - The end of the chunk will generate a `</div>` tag for each unpaired
   tag
 

## Processing

If we are going via a knitr engine route, then we need to apply our function
for handling the engine via `knitr::knit_engine$set()`. What happens inside of
that engine is ultimately up to us.

### Route: {knitr}

0. convert class tags to div tags (function: `make_div()`)
1. Transfer text to RMarkdown document (function: `tmp_rmd()`
2. Render RMarkdown to markdown (function: `knitr::knit()`)
3. Read in markdown document with `{up2code}` (function: `up2code::Episode$new()`)
5. render the output as-is 

#### Parsing Roxygen

I was looking into the processing and it seems that there are two different routes, even within {knitr}. There is adding a new tag and then going as far as adding a roclet. What we want to do is to create a new Rd tag. Details here: <https://roxygen2.r-lib.org/articles/extending.html>

The steps we want to do are:

1. Process the text with `roxygen2::parse_text(txt, env = NULL)`. Having the `env = NULL` there ensures that the code does not get evaluated.
2. Find the tags within the text 
3. Replace the tags in the text with div declarations and closings, depending on the previous tags

One of the problems I'm seeing with roxygen at the moment is the fact that not all of the code is processed. So if you have
a function definition and then another line after that, roxygen only sees that
first function definition. It may be better just go to through the code and
search for the `@challenge` and `@solution` tags to identify challenges and
solutions.
